inc stdlib.slm
inc log.slm

class sysc
  {TODO: finish}
  enum
  0   READ
      WRITE
      OPEN
      CLOSE
      STAT
      FSTAT
      LSTAT
      POLL

  12  BRK

  33  DUP2

  41  SOCKET
      CONNECT
      ACCEPT

  49  BIND
      LISTEN
    
  57  FORK
      VFORK
      EXECVE
      EXIT
      WAIT4
      KILL

  257 OPENAT
  end
end

class fm
  enum
  0   READ
      WRITE
      READWR
      ACC
  end
  
  const CREATE 0040h
  const EXCL   0080h
  const NOCTTY 0100h
  const TURNIC 0200h
  const NOBLOK 0400h
  const DSYNC  0800h
  const ASYNC  1000h
end

class os
  gvar waitsig 8
  
  proc fork 0 1
    sysc.FORK sys0
  
    ret
  end
  
  proc deverr 0 0
    "ERROR: cant open /dev/null" (cstr.println)
  
    -1 quit
    ret
  end
  
  {
  args: ptr[stringList]
  returns:
  
  runs a command
  }
  proc execcmd 1 0
    (os.fork)
    copy 0 == if [
      {child}
      1 {stdin}
      0
      fm.READ
      {TODO: magic num}
      "/dev/null"
      -100
      sysc.OPENAT sys4
      
      copy 0 < if (os.deverr)
     
      sysc.DUP2 sys2 0 < if (os.deverr)
  
      covr envp swap copy read
    
      sysc.EXECVE sys3 disc
      disc disc
      -1
      quit
    ]
    copy 0 > if [
      {parent}
  
      NULL
      0
      os.waitsig
      -1
      sysc.WAIT4 sys4 0 < if (os.deverr)
      disc disc
      ret
    ]
    0 < if [
      "ERROR" (cstr.println)
    ]
    disc
    ret
  end

  {
  args: ptr[stringList]
  returns: 
  
  prints a command then runs it
  }
  proc execcmdecho 1 0
    0 1 (log.level)
    "CMD" "Run: " (log.msg)
    copy
    do
      copy read (log.cat)
      int.SIZE +
       
      copy read NULL !=
      copy if [
        " " (log.cat)
      ]
    end
    disc
    (log.log)  

    (os.execcmd)
  
    ret
  end

  {
  args: int
  result: pointer
  
  gets the nth arguent from the command line
  }
  proc args 1 1
    copy argc - 0 < ! if [
      copy (int.print)
      "Bad arg" (int.print)
      disc -1 quit
    ]
    int.SIZE * 
    argv +
  
    read
    ret
  end

  {
  args: pointer int int
  result: int
  
  opens a file
  }
  proc open 4 1
    sysc.OPENAT sys4
  
    copy 0 < if [
      "Error opening file"
      disc disc -1 quit
    ]
    ret
  end

  {
  args: int ptr
  result: int
  
  writes data to a file
  }
  proc write 3 0
    sysc.WRITE sys3
  
    0 < if [
      "Error writing file"
      disc -1 quit
    ]
    ret
  end
  
  {
  args: int ptr
  result: int
  
  writes data to a file
  }
  proc read 3 1
    sysc.READ sys3
    
    copy 0 < if [
      "Error reading file"
      disc disc -1 quit
    ]
    ret
  end
  
  {
  args: int
  result:
  
  closes a file
  }
  proc close 1 0
    sysc.CLOSE sys1
  
    0 < if [
      "Error closing file"
      disc -1 quit
    ]
    ret
  end
end
